# NixOS Router Configuration
# This is the main system configuration file
# Most functionality is organized into modules in ./modules/

{ config, pkgs, lib, ... }:

let
  # Import router configuration variables
  routerConfig = import ./router-config.nix;
  pppoeEnabled = routerConfig.wan.type == "pppoe";

  # Helper to extract primary domain from DNS A records
  extractPrimaryDomain = aRecords:
    if aRecords == {} || aRecords == null then null
    else
      let
        firstRecord = builtins.head (builtins.attrNames aRecords);
        parts = lib.splitString "." firstRecord;
        numParts = builtins.length parts;
      in
        if numParts >= 2 then
          "${builtins.elemAt parts (numParts - 2)}.${builtins.elemAt parts (numParts - 1)}"
        else null;
  
  # Get primary domain for search suffix (from HOMELAB network)
  primaryDomain = extractPrimaryDomain (routerConfig.homelab.dns.a_records or {});

in

{
  imports = [
    # Hardware configuration (generated by nixos-generate-config)
      ./hardware-configuration.nix
    
    # All modules are now organized in ./modules/
    ./modules/router.nix       # Router networking (WAN, LAN bridges, firewall, NAT)
    ./modules/dns.nix          # DNS and DHCP server (dnsmasq with blocklists)
    ./modules/users.nix        # User account management
    ./modules/secrets.nix      # Secrets management (sops-nix)
    ./modules/dashboard.nix    # Monitoring (Grafana, Prometheus)
    ./modules/linode-dyndns.nix # Dynamic DNS updates
    ./modules/webui.nix        # Web UI monitoring dashboard
    ./modules/cake.nix         # CAKE traffic shaping (bufferbloat mitigation)
    ./modules/apprise.nix      # Apprise API notification service
    ];

  # Enable Nix flakes and modern command syntax
  nix.settings.experimental-features = [ "nix-command" "flakes" ];

  # Automatic garbage collection - runs daily and keeps only the past 2 generations
  nix.gc = {
    automatic = true;
    dates = "daily";
    options = "--delete-older-than 2d";
  };

  # Limit boot menu to 2 generations
  boot.loader.systemd-boot.configurationLimit = 2;

  # Bootloader configuration
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;

  # System identification
  networking.hostName = routerConfig.hostname;
  time.timeZone = routerConfig.timezone;
  i18n.defaultLocale = "en_US.UTF-8";

  # Disable systemd-resolved (conflicts with dnsmasq DNS)
  services.resolved.enable = false;
  
  # Configure DNS for the router itself
  # Use nameservers from router-config.nix
  networking.nameservers = routerConfig.nameservers or [
    routerConfig.homelab.ipAddress  # 192.168.2.1 - HOMELAB dnsmasq (fallback)
    routerConfig.lan.ipAddress       # 192.168.3.1 - LAN dnsmasq (fallback)
  ];
  
  # Explicitly manage /etc/resolv.conf to ensure it's populated on boot
  # This ensures nameservers are available even if networking module doesn't write it
  environment.etc."resolv.conf" = {
    text = ''
      # Generated by NixOS - do not edit manually
      ${lib.concatMapStringsSep "\n" (ns: "nameserver ${ns}") (routerConfig.nameservers or [
        routerConfig.homelab.ipAddress
        routerConfig.lan.ipAddress
      ])}
      ${lib.optionalString ((routerConfig.domain or "") != "") "search ${routerConfig.domain}"}
    '';
    mode = "0644";
  };
  
  # Add search domain so we can use short hostnames (e.g., "ssh hera" instead of "ssh hera.jeandr.net")
  # Use explicit domain from router-config.nix, fallback to extracted domain from DNS records
  networking.search = if (routerConfig.domain or "") != "" then
    [ routerConfig.domain ]
  else
    lib.optional (primaryDomain != null) primaryDomain;

  # Allow unfree packages (if needed for hardware drivers, etc.)
  nixpkgs.config.allowUnfree = true;

  # Router configuration
  router = {
    enable = true;
    
    # WAN interface configuration
    wan = {
       type = routerConfig.wan.type;
       interface = routerConfig.wan.interface;
    } // (if pppoeEnabled then {
      pppoe = {
        passwordFile = config.sops.secrets."pppoe-password".path;
        user = config.sops.secrets."pppoe-username".path;
        service = null;
        ipv6 = false;
      };
    } else {});
    
    # LAN configuration (multiple bridges with isolation)
    lan = {
      bridges = routerConfig.lan.bridges;
      isolation = routerConfig.lan.isolation or true;
      };
    
    # Firewall port allowances
    # Note: Port forwards (80, 443, 22000, 4242) do NOT need to be opened here
    # They are handled by NAT forwarding rules and should NOT be accessible on the router itself
    firewall = {
      allowedTCPPorts = [ ];
      allowedUDPPorts = [ ];
    };
    
    # Port forwarding rules (from router-config.nix)
    portForwards = routerConfig.portForwards or [];
    
    # Enable monitoring dashboard
    dashboard.enable = true;
  };

  # Fonts for WebUI (System Info rendering)
  fonts = {
    enableDefaultPackages = true;
    packages = with pkgs; [
      dejavu_fonts  # Monospace font for terminal output rendering
    ];
  };

  # Essential system packages (keep this minimal - use nix-shell for temporary tools)
  environment.systemPackages = with pkgs; [
    speedtest-cli  # Used regularly by monitoring timer
    curl           # Used by DynDNS timer (every 5 min) and health checks
    jq             # Used by DynDNS timer for JSON parsing
    cacert         # CA certificates for SSL/TLS
    fastfetch      # System information display tool (used by WebUI System Info)
  ];

  # DNS is configured via modules/dns.nix (reads from routerConfig.dns)
  # Firewall rules for DNS (port 53) are handled by the DNS module

  # WebUI configuration (from router-config.nix)
  services.router-webui = lib.mkIf (routerConfig.webui.enable or false) {
    enable = true;
    port = routerConfig.webui.port or 8080;
    collectionInterval = routerConfig.webui.collectionInterval or 2;
    debug = routerConfig.webui.debug or false;
    database = {
      host = routerConfig.webui.database.host or "localhost";
      port = routerConfig.webui.database.port or 5432;
      name = routerConfig.webui.database.name or "router_webui";
      user = routerConfig.webui.database.user or "router_webui";
    };
  };

  # Apprise notification service configuration (from router-config.nix)
  # Integrated with WebUI backend - no separate service needed
  services.apprise-api = lib.mkIf (routerConfig.apprise.enable or false) {
    enable = true;
  };

  # Enable SSH for remote administration
  services.openssh = {
    enable = true;
    settings = {
      PermitRootLogin = "no";
      PasswordAuthentication = true;
      KbdInteractiveAuthentication = true;
    };
  };

  # NixOS version (don't change unless you know what you're doing)
  system.stateVersion = "25.11";
}
